
## IO 演进之路
---

之前的高性能开发会有很多的缺陷。
* 没有缓冲区
* 没有Channel的概念，只有输入流和输出流。
* 同步阻塞IO，通常会导致线程长时间阻塞。
* 支持的字符串有限，硬件的可移植性有限。

---
#### Linux的网络IO的模型。
Linux将内核的所有外部设备都看作一个文件来看做。

UNIX提供了五中不同的IO模型。
* 最常用的阻塞IO模型：进程空间调用，此后一直等待，进程从到用到结束都是被阻塞的。
* 非阻塞IO模型：会检查缓冲区，轮询检查，看内核是否有数据到来。
* IO复用模型：Linux提供select/poll, epoll.
* 信号驱动IO模型：进程开启信号驱动模型，通过系统调用执行一个信号函数，进程调用后立即返回，非阻塞。当数据准备就绪时，为改进程生成一个信号，通知进程读取数据。
* 异步IO：进程告知内核启动操作，操作完成之后通知进程。

这里面有信号驱动是告诉我们什么时候数据准备好，异步IO是告诉我们什么时候IO操作已经完成（准备好内核数据到把数据复制到用户空间）。

---
#### IO多路复用模型


