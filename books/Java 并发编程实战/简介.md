# 第一章 简介

#### 线程的安全性问题
由于多个线程要共享相同的内存地址空间,并且是并发运行,因此它们可能会访问或修改其他线程正在使用的变量。当然,这是一种极大的便利,因为这种方式比其他线程间通信机制更容易实现数据共享。但它同样也带来了巨大的风险:线程会由于无法预料的数据变化而发生错误,当多个线程同时访问和修改相同的变量时,将会在串行编程模型中引入非串行因素,而这种非串行性是很难分析的。要使多线程程序的行为可以预测,必须对共享变量的访问操作进行协同,这样才不会在线程之间发生彼此干扰。幸运的是,Java提供了各种同步机制来协同这种访问。

#### 活跃性问题
在开发并发代码时,一定要注意线程安全性是不可破坏的。
安全性不仅对于多线程序很重要,对于单线程程序同样重要。线程还会导致一些在单线程程序中不会出现的问题,例如活跃性问题。
安全性的含义是“永远不发生糟糕的事情”,而活跃性则关注于另一个日标,即“某件正确的事情最终会发生”当某个操作无法继续执行下去时,就会发生活跃性问题。在串行程序中,活跃性问题的形式之一就是无意中造成的无限循环,从而使循环之后的代码无法得到执行,线程将带来其他一些活跃性问题,例如,如果线程A在等待线程B释放其持有的管源,而线程B水远都不释放该资源,那么A就会永久地等待下去,与大多数并发性错误一样,导致活跃性问题的错误同样是难以分析的,因为它们依赖于不同线程的事件发生时序,因此在开发或者测试中并不总是能够重现。

#### 性能问题
与活跃性问题密切相关的是性能问题,活跃性意味着某件正确的事情最终会发生,但却不够好,因为我们通常望正确的事情尽快发生,性能问题包括多个方面,例如服务时间过长,响应不灵敏,吞吐率过低,资源消耗过高,或者可伸缩性较低等。与安全性和活跃性一样,在多线程程序中不仅存在与单线程程序相同的性能问题,而且还存在由于使用线程而引入的其他性能问题

在设计良好的并发应用程序中,线程能提开程序的性能,但无论如何,线程总会带来某种程度的运行时开销,在多线程程序中,当线程调度器临时挂起活跃线程并转而运行另一个线程时,就会频繁地出现上下文切换操作( Conteut satch),这种操作将带来极大的开销:保存和恢复执行上下文,丢失局部性,并且CPU时间将更多地花在线程调度而不是线程运行上,当线程共享数据时,必须使用同步机制,而这些机制往往会制某些编译器优化,使内存缓存区中的数据无效,以及增加共享内存总线的同步流量,所有这些因素都将带来额外的性能开销。


# 第二章 线程安全性


## 什么是线程安全性
线程安全的核心概念是正确性。
当多个线程访问这个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能正确的表现出预期的行为， 那么这个类就是线程安全的。

> 无状态对象一定是线程安全的。

### 竞态条件
当某个计算的正确性取决于多个线程的交替执行时序时， 就会发生竞态条件。
最常见的竞态条件类型就是 **先检查后执行(check - then - act)** 操作， 即通过一个可能失效的观测结果来决定下一步的动作， 基于一种可能失效的观测结果来作出判断或者执行的结果。比如:首先观察到某个条件为真(例如文件X不存在),然后根据这个观察结果采用相应的动作(创建文件X),但事实上,在你观察到这个结果以及开始创建文件之间,观察结果可能变得无效(另一个线程在这期间创建了文件X),从而导致各种问题(未预期的异常、数据被覆盖、文件被破坏等)。

要避免竞态条件， 就必须在某个线程修改该变量时， 通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态， 而不能是在修改状态的过程中。

### 加锁

> 要保持状态的一致性，就需要在单个院子操作中更新所有相关的状态变量。

##### 重入
当某个线程请求一个有其他线程持有的锁时，发出请求的县城就会被阻塞，但是由于内置所是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。
> 重入意味着获取锁的力度是线程。

重入的一种是实现是,为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时,这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时,JVM将记下锁的持有者,并且将获取计数值置为1。如果同一个线程再次获取这个锁,计数值将递增,而当线程退出同步代码块时,计数器会相应地递减。当计数值为0时,这个锁将被释放。

重入进一步提升了加锁行为的封装性,因此简化了面向对象并发代码的开发。

子类改写了父类的 synchronized方法,然后调用父类中的方法,此时如果没有可重入的锁,那么这段代码将产生死锁。由于 Widget和 LoggingWidget中 dosomething方法都是 synchronized方法,因此每个 dosomething方法在执行前都会获取 Widget上的锁。然而,如
果内置锁不是可重入的,那么在调用 super.doSomething时将无法获得 Widget上的锁,因为这个锁已经被持有,从而线程将永远停顿下去,等待一个永远也无法获得的锁。重入则避免了这种死锁情况的发生。

```Java
class Widget {
    public synchronized void doSomthing() {
        System.out.println("super class do something.");
    }

}

class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println("call super class");
        super.doSomthing();
    }
}

//client
public static void main(String[] args) {
    new LoggingWidget().doSomething();
}

```

output:
```
call super class
super class do something.
```



> 对于可能被多个线程同时访问的可变状态变量,在访问它时都需要持有同一个,在这种情况下,我们称状态变量是由这个锁保护的。

大量滥用synchronized的结果是：大量的请求将会排队等待处理。也称之为 **不良并发应用程序**：可同事调用的数量不仅受制于资源， 同时也受到了应用程序本身结构的限制。
要确保同步代码块不要过小， 并且不要将本应是院子的操作拆分到不同的同步代码块中， 应该尽量注意将不影响共享状态切执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问这些共享状态。



# 对象的共享
要真正编写正确的并发程序， 问题的关键在于：在访问共享的可变状态时需要进行正确的管理。

### 可见性
一个线程对共享变量的修改，能被其他线程适时的看到变化。
##### 失效数据
Java内存模型要求， 变量的读取操作和写入操作都必须是原子操作， 但是对非volitile类型的long和double变量，JVM 语序将64位的读写操作分解为两个32位的操作。
这就导致了如果对该变量的读写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值得低32位。

现在,我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步,就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则,如果个线程在未持有正确锁的情况下读取某个变量,那么读到的可能是一个失效值。

加锁的含义不仅仅局限于互斥行为,还包括内存可见性。为了确保所有线程都能看到共享变量的最新值,所有执行读操作或者写操作的线程都必须在同一个锁上同步。

##### volatile
Java提供了volatile变量来确保变量的更新操作通知到其他线程。当把变量声明为 volatile类型后,编译器与运行时都会注意到这个变量是共享的,因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方,因此在读取 volatile类型的变量时总会返回最新写入的值。

volatile变量对可见性的影响比volatile变量本身更为重要。当线程A首先写入一个volatile变量并且线程B随后读取该变量时,在写人 volatile变量之前对A可见的所有变量的值,在B读取了volatile变量后,对B也是可见的。
因此,从内存可见性的角度来看,写入volatile変量相当于退出同步代码块,而读取volatile变量就相当于进入同步代码块。然而,我们并不建议过度依赖volatile变量提供的可见性。如果在代码中依赖 volatile变量来控制状态的可见性,通常比使用锁的代码更脆弱,也更难以理解。

>仅当volatile变量能简化代码的实现以及对同步策略的验证时,才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断,那么就不要使用 volatile变量。volatile变量的正确使用方式包括:确保它们自身状态的可见性,确保它们所引用对象的状态的可见性,以及标识一些重要的程序生命周期事件的发生(例如,初始化或关闭)。


**加锁机制可以保证原子性和可见性，但是volatile只能保证可见性。**



### 线程封闭
当访问共享的可变数据时，通常需要使用同步。
一种避免使用同步的方式就是不共享数据。如果仅仅是在单线程中访问数据，就不需要同步。
这种技术被称为线程封闭，也是实现线程安全的最简单方式之一。

##### 栈封闭
局部变量的固有属性之一就是封闭在执行线程中。

##### ThreadLocal
更规范的方法是使用ThreadLocal， 这个类能够使线程中的某个值与保存至的对象关联起来。

ThreadLocal对象通常用于防止对可变的单实例变量或全局变量进行共享。


### 不可变
不可变对象很简单，他们只有一种状态，并且该状态由构造函数来控制。
不可变对象一定是线程安全的。

当满足以下条件时,对象才是不可变的
- 对象创建以后其状态就不能修改。
- 对象的所有域都是fnal类型。
- 对象是正确创建的(在对象的创建期间,this引用没有逸出)。


### 使用Volatile 来发布不可变对象
对于有多个变量需要同步时， 我们可以使用不可变对象配合volatile来发布。

对于访问和更改多个相关变量时出现在竞争条件， 可以通过将这些变量全部保存在一个不可变对象中消除。
如果是一个可变对象，那么就必须使用锁来确保原子性，如果是不可变对象，那么当线程获得了该对象的引用后，就不必担心另一个线程会修改对象的状态， 如果要更新这些变量，那么就是创建一个新的容器对象，volatile又保证了其他对象仍然会看到处于一致的状态。
