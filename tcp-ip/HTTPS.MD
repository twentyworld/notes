# HTTPS

## 1 前言

### 1.1 什么是HTTPS
在说`HTTPS`之前先说说什么是`HTTP`，`HTTP`就是我们平时浏览网页时候使用的一种协议。`HTTP`协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是网景公司设计了`SSL`（`Secure Sockets Layer`）协议用于对HTTP协议传输的数据进行加密，从而就诞生了`HTTPS`。

`SSL`目前的版本是3.0，被`IETF（Internet Engineering Task Force）`定义在`RFC 6101`中，之后`IETF`对`SSL 3.0`进行了升级，于是出现了`TLS（Transport Layer Security） 1.0`，定义在`RFC 2246`。实际上我们现在的HTTPS都是用的`TLS`协议，但是由于`SSL`出现的时间比较早，并且依旧被现在浏览器所支持，因此`SSL`依然是`HTTPS`的代名词，但无论是`TLS`还是`SSL`都是上个世纪的事情，`SSL`最后一个版本是3.0，今后`TLS`将会继承`SSL`优良血统继续为我们进行加密服务。目前`TLS`的版本是1.2，定义在`RFC 5246`中，暂时还没有被广泛的使用。

HTTP 属于应用层协议， TLS属于会话层协议。
---

## 2 预读知识
### 2.1 内容加密
加密算法一般分为两种，对称加密和非对称加密。所谓对称加密(也叫密钥加密)就是指加密和解密使用的是相同的密钥。而非对称加密(也叫公钥加密)就是指加密和解密使用了不同的密钥。

对称内容加密强度非常高，一般破解不了。但存在一个很大的问题就是无法安全地生成和保管密钥。假如客户端软件和服务器之间每次会话都使用固定的，相同的密钥加密和解密，肯定存在很大的安全隐患。如果有人从客户端端获取到了对称密钥，整个内容就不存在安全性了，而且管理海量的客户端密钥也是一件很复杂的事情。

非对称加密主要用于密钥交换(也叫密钥协商)，能够很好地解决这个问题。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同。

#### 2.1.1 非对称密钥交换
在非对称密钥交换算法出现以前，对称加密一个很大的问题就是不知道如何安全生成和保管密钥。非对称密钥交换过程主要就是为了解决这个问题，使得对称密钥的生成和使用更加安全。

密钥交换算法本身非常复杂，密钥交换过程涉及到随机数生成，模指数运算，空白补齐，加密，签名等操作。

RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数(目前常用的是 2048 位)来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。

**建议优先支持 RSA。**

**非对称加密相比对称加密更加安全，但也存在两个明显缺点**：
1. CPU 计算资源消耗非常大。一次完全 TLS 握手，密钥交换时的非对称解密计算量占整个握手过程的 90% 以上。而对称加密的计算量只相当于非对称加密的 0.1%，如果应用层数据也使用非对称加解密，性能开销太大，无法承受。

2. 非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。

所以公钥加密目前只能用来作密钥交换或者内容签名，不适合用来做应用层传输内容的加解密。非对称密钥交换算法是整个 HTTPS 得以安全的基石，充分理解非对称密钥交换算法是理解 HTTPS 协议和功能的关键。


#### 2.1.2 对称内容加密
非对称密钥交换过程结束之后就得出了本次会话需要使用的对称密钥。对称加密又分为两种模式：流式加密和分组加密。








## HTTPS 验证原理
![原理图][1]

1. 客户端发起一个https的请求，把自身支持的一系列Cipher Suite（密钥算法套件，简称Cipher）发送给服务端。

2. 服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法以证书的形式返回给客户端 证书中还包含了公钥、颁证机构、网址、失效日期等等。

4. 客户端收到服务端响应后会做以下几件事
>   4.1 验证证书的合法性颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等
>   证书验证通过后，在浏览器的地址栏会加上一把小锁(每家浏览器验证通过后的提示不一样 不做讨论)
>   
>   4.2 生成随机密码
>   如果证书验证通过，或者用户接受了不授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。 　　　　　　
>   
>   4.3 HASH握手信息
>   用最开始约定好的HASH方式，把握手消息取HASH值，  然后用 随机数加密 “握手消息+握手消息HASH值(签名)”  并一起发送给服务端
>   在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。

6. 服务端拿到客户端传来的密文，用自己的私钥来解密握手消息取出随机数密码，再用随机数密码解密握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值 )给客户端

7. 客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全。

## 总结

###优点
总体来说，HTTPS 协议提供了三个强大的功能来对抗劫持行为：
1. 内容加密。浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。
2. 身份认证。保证用户访问的是百度服务，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持。
3. 数据完整性。防止内容被第三方冒充或者篡改。



[1]:https://images2015.cnblogs.com/blog/366784/201601/366784-20160127222221785-258650029.png
