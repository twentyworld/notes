1. 项目中使用了那些框架，项目如何部署，都有哪些组件，项目中使用了cache吗，hbase吗
2. Jvm, 内存回收机制，在老年代里面，什么时候会锁住用户线程
3. Hashmap， 什么情况下性能比较差，怎么解决，为什么使用ConcurentHashMap
4. 如何设计一个秒杀系统，Cache， cdn， Cache怎么设计，数据库的热点数据问题，当cache挂了怎么办
    连接池不能解决真正的问题，热点问题如何做
5. 数据库的索引的数据结构，为什么使用b+树，数据库隔离级别，为什么使用这个隔离级别，跟Oracle有什么区别，不同的隔离级别下都会有什么问题
6. 分布式框架，为什么使用这个框架，怎么选择的， Eureka的实现原理，
7. 如何设计路由，如何设计负载均衡，为什么，使用了哪些负载均衡工具，负载均衡算法
8. 分库分表，怎么做， 你认为系统中哪些可以做分库分表
9. 一致性哈希是什么，有哪些情况下适用于一致性哈希
10. 假如发生了OOM，你怎么排查，如何排查，线上问题






10. 假如发生了OOM，你怎么排查，如何排查，线上问题
- 查看log，一般会有各种各样的监控

- 重启，复盘问题
  > jstat -gcutil pid interval 用于查看当前GC的状态,它对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。
  > Full GC次数远大于Young GC。 由此可见可能是老年代空间大小不足，导致应用需要频繁Full GC，因为Full GC要将新生代、旧生代、持久代一起进行GC。
  >  jmap -histo:live pid 可用统计存活对象的分布情况，从高到低查看占据内存最多的对象。
  > Java dump，也叫做 Thread dump，是 JVM 故障诊断中最重要的转储文件之一。JVM 的许多问题都可以使用这个文件进行诊断，其中比较典型的包括线程阻塞，CPU 使用率过高，JVM Crash，堆内存不足，和类装载等问题。 然后用MAT（eclipse Memory Analyzer）工具导入文件，生成类报告：
  > gcore 出现了这个问题后，再其他同学的提醒下，我们尝试了gcore。在排查问题的时候，对于保留现场信息的操作，可以用gcore [pid]直接保留内存信息，这个的执行速度会比jmap -dump快不少，之后可以再用jmap/jstack等从core dump文件里提取相应的信息。
  > GC日志
  > 问题解决之后，突然想起线上项目启动的时候是有配置OOM发生时生成dump文件的配置，在启动脚本里面看到有针对OOM的指令：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=文件储存路径；

- dmesg dmesg可以用来查看开机之后的系统日志，其中可以捕捉到一些系统资源与进程的变化信息。dmesg |grep -E ‘kill|oom|out of memory’ 来搜索内存溢出的信息挺实用
-
