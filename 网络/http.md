# HTTP

  - HTTP构建于`TCP/IP`协议之上，默认端口号是80。
  - HTTP是 **无连接无状态** 的。

无连接的含义是 **限制每次连接只处理一个请求**。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。后来使用了`Keep-Alive`技术。

无状态是指 **协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态**。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。

HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，**缺点在于每次请求会传输大量重复的内容信息**。

为了解决HTTP无状态的缺点，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 `Cookie`，而另一个则是 `Session`。`Cookie`在客户端记录状态，比如登录状态。`Session`在服务器记录状态。


## Http的报文结构

### HTTP 请求报文头部

  - `User-Agent`：产生请求的浏览器类型。
  - `Accept`：客户端可识别的响应内容类型列表;
  - `Accept-Language`：客户端可接受的自然语言;
  - `Accept-Encoding`：客户端可接受的编码压缩格式;
  - `Accept-Charset`：可接受的应答的字符集;
  - `Host`：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;
  - `Connection`：连接方式(close 或 `keep-alive`);
  - `Cookie`：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;
  - `请求包体`：在`POST`方法中使用。
  - `Referer`：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
  - `If-Modified-Since`：文档的最后改动时间

### HTTP 响应头

  - `Allow`	服务器支持哪些请求方法（如GET、POST等）。
  - `Content-Encoding`	文档的编码（Encode）方法。
  - `Content-Length`	表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。
  - `Content-Type`	表示后面的文档属于什么MIME类型。
  - `Date`	当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
  - `Expires`	应该在什么时候认为文档已经过期，从而不再缓存它。
  - `Last-Modified`	文档的最后改动时间。
  - `Refresh`	表示浏览器应该在多少时间之后刷新文档，以秒计。
  - `Server`	服务器名字。
  - `Set-Cookie`	设置和页面关联的Cookie。
  - `ETag`：被请求变量的实体值。ETag是一个可以与Web资源关联的记号（MD5值）。
  - `Cache-Control`：这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。

  > max-age：表示当访问此网页后的 x 秒内再次访问不会去服务器；no-cache，实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性；no-store，这个才是响应不被缓存的意思；

>`Last-Modified`与`If-Modified-Since`都是用来记录页面的最后修改时间。当客户端访问页面时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的cache页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的最后修改时间戳发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则返回 304。

## Http的状态码含义。

  - `1**`	信息，服务器收到请求，需要请求者继续执行操作
  - `2**`	成功，操作被成功接收并处理
  - `3**`	重定向，需要进一步的操作以完成请求
    - `301 Moved Permanently`。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
    - `302 Moved Temporarily`。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
    - `304 Not Modified`。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。**客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源**。
  - `4**`	客户端错误，请求包含语法错误或无法完成请求
    - `400 Bad Request` 由于客户端请求有语法错误，不能被服务器所理解。
    - `401 Unauthorized` 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用
    - `403 Forbidden` 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
    - `404 Not Found` 请求的资源不存在，例如，输入了错误的URL
  - `5**`	服务器错误，服务器在处理请求的过程中发生了错误
    - `500 Internal Server Error` 服务器发生不可预期的错误，导致无法完成客户端的请求。
    - `503 Service Unavailable` 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

## Http request的几种类型。

  - `GET`	请求指定的页面信息，并返回实体主体。
  - `POST`	向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
  - `PUT`	从客户端向服务器传送的数据取代指定的文档的内容。
  - `DELETE`	请求服务器删除指定的页面。

  >GET可提交的数据量受到URL长度的限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制

  >理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制

## 条件 GET

HTTP条件GET 是 `HTTP` 协议为了减少不必要的带宽浪费，提出的一种方案。实际上就是利用`If-Modified-Since`做浏览器缓存。

## 持久连接

我们知道 HTTP 协议采用`请求-应答`模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用 `Keep-Alive 模式`（又称持久连接、连接重用）时，`Keep-Alive` 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，`Keep-Alive` 功能避免了建立或者重新建立连接。

在 HTTP 1.0 中, 没有官方的 `keep alive` 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：

```
Connection: Keep-Alive
```

然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：

```
Connection: Keep-Alive
```

这样做，连接就不会中断（超过 Keep-Alive 规定的时间--服务器设置，意外断电等情况除外），而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。

在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 "Connection: close" 才关闭。

> HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。

> **HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开**。

> HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，**Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的**，在HTTP1.1版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于Keep-Alive的保持连接特性，否则会有意想不到的后果。

> 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。

## 跨站攻击

CSRF（Cross-site request forgery，跨站请求伪造）伪造请求，冒充用户在站内的正常操作，比如爬虫。

### 防范的方法

  - 关键操作只接受POST请求
  - 验证码
  - 检测 Referer
  - Token
    - Token 要足够随机——只有这样才算不可预测
    - Token 是一次性的，即每次请求成功后要更新Token——这样可以增加攻击难度，增加预测难度
    - Token 要注意保密性——敏感操作使用 post，防止 Token 出现在 URL 中

## 断点续传

要实现断点续传的功能，通常都需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。

HTTP1.1协议中定义了断点续传相关的HTTP头 `Range` 和 `Content-Range` 字段，一个最简单的断点续传实现大概如下：
  1. 客户端下载一个1024K的文件，已经下载了其中512K
  2. 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：`Range:bytes=512000-`，这个头通知服务端从文件的512K位置开始传输文件。
  3. 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：`Content-Range:bytes 512000-/1024000`，并且此时服务端返回的HTTP状态码应该是`206`，而不是200。

但是在实际场景中，会出现一种情况，即在终端发起续传请求时，URL对应的文件内容在服务端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？显然此时我们需要有一个标识文件唯一性的方法。在RFC2616中也有相应的定义，比如 **实现Last-Modified来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动**。同时RFC2616中还定义有一个ETag的头，可以使用ETag头来放置文件的唯一标识，比如文件的MD5值。

客户端在发起续传请求时应该在HTTP头中申明`If-Match` 或者 `If-Modified-Since` 字段，帮助服务端判别文件变化。
### HTTP状态码
* 100 请求者应继续进行请求。服务器返回此代码以表示，服务器已收到某项请求的第一部分，正等待接收剩余部分。

* 101 请求者已要求服务器切换协议，服务器已确认并准备切换。

* 200 服务器已成功处理相应请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，则表示 Googlebot 已成功检索到该文件。

* 201 请求成功且服务器创建了新的资源。

* 202 服务器已接受相应请求，但尚未对其进行处理。

* 203 服务器已成功处理相应请求，但返回了可能来自另一来源的信息。

* 204 服务器已成功处理相应请求，但未返回任何内容。

* 205 服务器已成功处理相应请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）

* 206 服务器成功处理了部分 GET 请求。

* 300 服务器可以根据请求来执行多项操作，例如：按照请求者（用户代理）的要求来选择某项操作或者展示列表以便请求者选择其中某项操作。

* 301 请求的网页已被永久迁移至新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久迁移至新位置。

* 302 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被迁移。

* 303 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。

* 304 请求的网页自上次请求后再也没有修改过。当服务器返回此响应时，不会返回相关网页的内容。
如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。

* 305 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么服务器还会指明请求者应当使用的代理。

* 307 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被迁移。

* 400 服务器不理解请求的语法。

* 401 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。

* 403 服务器正在拒绝相应请求。如果 Googlebot 在尝试抓取网站的有效网页时收到此状态代码（您可在 Google Search Console 中运行状况下的抓取错误页上进行查看），则可能是因为您的服务器或主机正在阻止 Googlebot 进行访问。

* 404 服务器找不到请求的网页。例如，如果相应请求是针对服务器上不存在的网页进行的，那么服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google Search Console 中的已拦截的网址页上看到此状态，那么这就是正确的状态。但是，如果您有 robots.txt 文件而又看到此状态，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域名上，且应当名为 robots.txt）。如果您在 Googlebot 尝试抓取的网址上看到此状态，那么这表示 Googlebot 追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。

* 405 禁用请求中所指定的方法。

* 406 无法使用请求的内容特性来响应请求的网页。

* 407 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。

* 408 服务器等待请求超时。

* 409 服务器在完成请求时遇到冲突。服务器必须在响应中包含该冲突的相关信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。

* 410 如果请求的资源已被永久移除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。

* 411 服务器不会接受包含无效内容长度标头字段的请求。

* 412 服务器未满足请求者在请求中设置的其中一个前提条件。

* 413 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。

* 414 请求的 URI（通常为网址）过长，服务器无法进行处理。

* 415 请求的格式不受请求页面的支持。

* 416 如果相应请求是针对网页的无效范围进行的，那么服务器会返回此状态代码。

* 417 服务器未满足“期望”请求标头字段的要求。

* 500 服务器遇到错误，无法完成请求。

* 501 服务器不具备完成相应请求的功能。例如，当服务器无法识别请求方法时，可能便会返回此代码。

* 502 服务器作为网关或代理，从上游服务器收到了无效的响应。

* 503 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。

* 504 服务器作为网关或代理，未及时从上游服务器接收请求。

* 505 服务器不支持相应请求中所用的 HTTP 协议版本。
