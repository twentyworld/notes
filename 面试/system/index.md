# 操作系统

## 相关概念

- 同步异步，阻塞非阻塞
  - 同步：等待执行完
  - 异步：不等待执行完就开始执行其他的，例如多线程
  - 阻塞：调用之后不一定会立即返回
  - 非阻塞：调用之后，会立即返回

- 孤儿进程，僵尸进程
  - 孤儿进程是父进程退出的，那个子进程叫做孤儿进程
  - 僵尸进程是子进程退出了但是父进程没有wait的，那个退出的子进程是僵尸进程

- 操作系统调度算法
  - 先来先服务
  - 短作业优先
  - 优先级调度
  - 时间片轮转
  - 多级反馈队列调度算法
  - Linux内核：完全公平调度算法

- 死锁出现条件
  - 互斥
  - 持有并等待
  - 循环等待
  - 没有抢占

- 线程和进程的区别
  - 进程是程序执行的实体，是操作系统提供的一个抽象概念
  - 线程是操作系统调度的最小单元
  - 线程是在进程的空间内，同一进程内的所有线程共享进程的所有资源如fds，stack等

- 进程间通信方式
  - 管道
  - 文件
  - socket
  - 共享内存(mmapped-file也算一种共享内存)
  - 信号量
  - 消息队列

- fork之后子进程从父进程继承的东西
  - real user id, real group id, effective id, effective group id
  - process group id
  - session id
  - controlling terminal
  - set-user, set-group flags
  - current working directory
  - file mode creation mask
  - environment
  - memory mappings
  - resource limits
  - opened file descriptors

- fork之后父子进程的区别
  - the return value from fork
  - parent pid
  - pid

- fork之后只有调用fork的线程被保存，其他线程被销毁。但是其他属性如opened file descriptors，锁等会被保留

- 线程间同步方式
  - mutex
  - read-write lock & lock
  - condition variables
  - spin locks
  - barriers(内存屏障)

- 分页，分段
  - 早期直接使用物理内存，缺点：
    - 地址空间不隔离
    - 内存使用效率低，一个程序执行时，需要将整个程序载入内存，由于程序的地址空间是连续的，如果忽然要执行C，可能就要将已有的程序A放到磁盘。
    - 程序的运行地址不确定
  - 虚拟地址
    - 不直接使用物理内存，而是通过映射。这样解决了程序运行地址不确定的问题
    - 分段：基本思路是把一段程序所需要的内存空间大小的虚拟空间映射到某个地址，然后从物理地址找一块一样大小的地址，进行映射。解决了上面所说的第一个和第三个问题。
      - A程序和B程序分别被映射到了不痛得物理空间区域，他们没有任何重叠
      - 无论实际上被分配到哪一个物理区域，对于程序来说都是透明的，程序不需要关心物理地址的变化，只需要按照地址从0x00000000到0x00A000000写程序即可
    - 分页。根据程序的局部性原理，一个程序运行时，总是频繁的用到其中一小段数据。分页的基本方法是把地址空间人为的分为固定的大小，每一页的大小由硬件决定，通常是4KB-4MB。当我们把进程的虚拟空间按照分页之后，就可以只加载其中一部分，从而提高了内存的使用效率。
    - 页错误：当进程需要用到某个分页的内容，但是却不在内存里，硬件就会报页错误。
        然后由操作系统接管进程，负责将需要的页加到内存然后继续后面的动作。

- 内核线程与用户线程的三种模型
  - 一对一
  - 一对多
  - 多对多