# Redis面试常见题
## 1. 什么是redis?
Redis 是一个基于内存的高性能key-value数据库。 以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。

Redis跟memcache不同的是，储存在Redis中的数据是持久化的，断电或重启后，数据也不会丢失。因为Redis的存储分为内存存储、磁盘存储和log文件三部分，重启后，Redis可以从磁盘重新将数据加载到内存中，这些可以通过配置文件对其进行配置，正因为这样，Redis才能实现持久化。

Redis支持主从模式，可以配置集群，这样更利于支撑起大型的项目，这也是Redis的一大亮点。

## 2. Reids的特点
- **高性能**: Redis是用C语言实现的, 并且数据都存储在内存中，查询数据很快。
- **分布式**: redis通过槽管理方式，将所有的key分布在不同的槽，又将槽指定给不同的master节点。
- **高可用性**: redis采用了主从设计，每个master节点都可以配置若干个从服务器。master向外提供读写服务，而从服务器用于同步master节点的缓存数据。**Redis-Sentinel**监听所有的监听所有的Redis主从服务器，一旦发现主服务器挂掉了，他会从若干服务器中选择一台新的机器作为master，其他从服务器会成为这台新master的从服务器。
- **可伸缩性**: 当集群加入新的master节点，可以通过重新分配槽的方式，均衡各个服务器压力。一般采用reshard和rebalance函数来完成重新分槽和再均衡过程。
- **单线程**: 利用redis队列技术并将访问变为串行访问，消除了传统数据库串行控制的开销。 减少并发控制的复杂度。
- **持久化**: Redis的所有数据存储在内存中，对数据的更新将异步地保存到磁盘上。

## 3. redis的优点和缺点
### 3.1 优点

- 单线程，利用redis队列技术并将访问变为串行访问，消除了传统数据库串行控制的开销。减少并发控制的复杂度。
- redis具有快速和持久化的特征，速度快，因为数据存在内存中。
- 分布式 读写分离模式
- 支持丰富数据类型
- 支持事务，操作都是原子性，所谓原子性就是对数据的更改要么全部执行，要不全部不执行。
- 可用于缓存，消息，按key设置过期时间，过期后自动删除
- 加上上一条redis特点: 高性能、分布式、高可用、可伸缩性、单线程、持久化等

### 3.2 缺点

## 4. redis支持的数据类型
每种基本类型都有两种或以上的编码方式，不同的编码可以在不同场景上优化对象的使用效率。

- **字符串String**: 
    - 对象底层数据结构可以是 int(整数值，整数值用long表示然后存到int中)、embstr(小于32字节)和raw
    - 命令**SET和GET**
- **列表List**
    - 数据结构采用ziplist(每个元素都小于64字节，并且个数少于512)或linklist
    - 命令字**LPUSH和LRANGE**
- **字典Hash**: 
    - 数据结构采用zipList(所有健和value都小于64字节，并且个数少于512)和HashTable
    - 命令**HMSET和HGET**
- **集合Set**:
    - 数据结构采用inset(都是整数，并且个数小于512)和hashTable
    - 命令**sadd**和**smembers** 
- **有序集合ZSet**
    - 数据结构采用zipList（每个元素小于64字节，并且元素个数小于**128**）或skipList
    - 命令**zadd**和**ZRANGEBYSCORE**
- **HyperLogLog**: Redis中hyperloglog是用来做基数统计的，其优点是：在输入元素的数量或者体积非常非常大的时候，计算基数所需的空间总是固定的，并且是很小的。在 Redis 里面，每个HyperLogLog 键只需要花费12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

### 基数和基数计算
基数(cardinality)，是指一个集合中不同元素的个数。例如集合：{1,2,3,4,5,2,3,9,7}， 这个集合有9个元素，但是2和3各出现了两次，

因此不重复的元素为1,2,3,4,5,9,7，所以这个集合的基数是7。

那什么是**基数统计**呢？基数统计是指在误差允许的情况下估算出一组数据的基数。

从上述的概念中，我们可以很容易想到基数统计的用途，假设需要计算出某个网站一天中的独立ip访问量，相同ip访问多次的话值算作一次。这个问题即可转换成求一天内所有访问该网站的ip数组的基数。关键在于如何求这个基数？下面我就以最易懂的方法来给大家讲一下。


更多参考: 

- [Redis HyperLogLog](https://www.cnblogs.com/xiaozong/p/5647981.html)
- [Redis源码剖析--基数统计hyperloglog](https://blog.csdn.net/terence1212/article/details/53543801)

如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。
如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。


## Redis应用场景




## 3. AOF和 RDB的区别
### 二者区别
RDB持久化是指在指定的时间间隔内将内存中的**数据集快照**写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

AOF持久化以日志的形式记录服务器所处理的每一个**写、删除操作**，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。


### RDB
RDB相当于redis镜像，用于保存和还原Redis服务器所有数据库中的所有键值对数据。

RDB文件的载入工作是服务器启动是自动加载，没有专门的命令字，只要服务启动的时候发现RDB文件存在，就自动载入。

执行频率，默认：

- 900 1 （900秒）
- 300 10
- 60 10000

实现：

- dirty: 上次修改次数
- lastsave： 上次保存时间
- serverCron每100毫秒检查一次

### AOF
通过持久化保存redis服务器所执行的命令字来记录数据库状态。

AOF持久化功能分为： 命令追加append、文件写入、文件同步sync三个步骤。

- 命令追加append：以协议方式追加到aof_buf缓存中
- 文件写入和同步: serverCron函数在结束循环之前，调用flushAppendOnlyFile函数考虑将aof_buf缓存区内容写入到AOF文件。有三种形式
    - always: 写入是总是同步磁盘
    - everysec: 写入，并每秒同步
    - no: 不进行同步操作，由操作系统决定同步时间

载入时会创建一个不带网络连接的伪客户端。执行AOF指令，进行还原。

重写：

- 重写是读数据库数据，生成AOF指令。 
- AOF重写在子进程中执行
- 同时将命令写入AOF缓存和AOF重写缓存
- 重写完成，发送信号。
- 父进程停止工作，将AOF重写缓存写入文件。
- 替换文件。---原子性


### 优缺点
#### RDB存在哪些优势
- **灵活设置备份频率和周期**。你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。

- 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。

- 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。

- 相比于AOF机制，如果数据集很大，RDB的**启动效率会更高**。

#### RDB的缺点
- 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。

- 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

#### AOF的优势
- 该机制可以带来更高的**数据安全性**，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。

- 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。

- 如果日志过大，Redis可以自动启用**rewrite**机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。

- AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。

#### AOF不足
- 对于相同数量的数据集而言，**AOF文件通常要大于RDB文件**。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

- 根据同步策略的不同，**AOF在运行效率上往往会慢于RDB**。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。


## 4. skiplist插入和查询原理（来自360）

## 5. redis持久化方式（百度）
### 1. RDB快照（snapshots）
缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。

工作原理:

- Redis forks.
- 子进程开始将数据写到临时RDB文件中。
- 当子进程完成写RDB文件，用新文件替换老文件。
- 这种方式可以使Redis使用copy-on-write技术。

### 2. AOF
快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。这对某些应用也许不是大问题，但对于要求高可靠性的应用来说Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式


## 6. redis过期时间如何实现（来自58赶集）

## 7. 压缩列表的原理（来自360）

## 8. redis如何清除过期keys

- 定期删除
- 懒惰删除

## 9. redis底层为什么使用跳跃表而不是红黑树
跳跃表在范围查找的时候性能比较高

## 10. 使用过Redis分布式锁么，它是什么回事？
先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？

这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。


## 11. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。

对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

## 12. bgsave的原理是什么？
你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

## 13. Redis的同步机制了解么？
**Redis可以使用主从同步，从从同步**。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

## 14. 是否使用过Redis集群，集群的原理是什么？
Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

## 15. 为什么redis需要把所有数据放到内存中?
Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。

如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

## 16. Redis是单进程单线程的
redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销

## 17. redis的并发竞争问题如何解决?
Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：

1. 客户端角度，为保证每个客户端间正常有序与Redis进行通信，**对连接进行池化**，同时对客户端读写Redis操作采用内部锁synchronized。

2. 服务器角度，利用setnx实现锁。

注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。

## 使用redis有哪些好处？
- **速度快**，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
- **支持丰富数据类型**，支持string，list，set，sorted set，hash
- **支持事务**，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
- **丰富的特性**：可用于缓存，消息，按key设置过期时间，过期后将会自动删除


## Memcache与Redis的区别都有哪些？
- **1)、存储方式**
Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。

- **2)、数据支持类型**
Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能。Redis有复杂的数据类型,Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。

- **3)、使用底层模型不同**
它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

- **4）value大小**
redis最大可以达到1GB，而memcache只有1MB

- **5) Redis支持数据的备份，即master-slave模式的数据备份。**
- **6)、查询速度，redis速度比memchached快** 为什么？
- 7) Memcached是多线程，非阻塞IO复用的网络模型。Redis使用单线程的IO复用模型，自己封装了一个简单的AeEvent事件处理框架。

## 如何提高redis命中率
## redis主从是如何实现同步的
## redis主从中的哨兵是做什么的
Redis的哨兵模式就是对redis系统进行实时的监控，其主要功能有下面两点:

1. 监测主数据库和从数据库是否正常运行。
2. 当我们的主数据库出现故障的时候，可以自动将从数据库转换为主数据库，实现自动的切换   

## 谈谈redis的LRU算法
答：LRU即最近最久未使用，当内存达到限制时，Redis 具体的回收策略是通过 maxmemory-policy 配置项配置的。由以下多个选项：

- **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰，以供新数据使用
- **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰，以供新数据使用
- **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，以供新数据使用
- **allkeys-lru**：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，以供新数据使用
- **allkeys-random**：从所有数据集（server.db[i].dict）中任意选择数据淘汰，以供新数据使用
- **no-eviction**：不清除数据，只是返回错误，这样会导致浪费掉更多的内存，对大多数写命令（DEL 命令和其他的少数命令例外）

当 cache 中没有符合清除条件的key时，回收策略 volatile-lru, volatile-random 和volatile-ttl 将会和策略 noeviction 一样返回错误。选择正确的回收策略是很重要的，取决于你的应用程序的访问模式。

回收的过程是这么运作的非常的重要：

- 一个客户端运行一个新命令，添加了新数据。
- Redis 检查内存使用情况，如果大于**maxmemory**限制，根据策略来回收键。
- 一个新的命令被执行，如此等等

Redis的LRU算法不是一个严格的LRU实现。这意味着Redis不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的LRU算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久访问时间)的那个。

## mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据



## Redis 常见的性能问题都有哪些？如何解决？

- **Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件**. Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。

- 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
- 尽量避免在压力很大的主库上增加从库
- Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。
- Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内


# redis 最适合的场景
Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?

- **（1）会话缓存（Session Cache）**
    最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。

- **（2）、全页缓存（FPC）**
    除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。
再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。

    此外，对WordPress的用户来说，Pantheon有一个非常好的插件  wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

- **（3）、队列**
    Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。

    如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。

- **（4），排行榜/计数器**
    Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：

    当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：

    ZRANGE user_scores 0 10 WITHSCORES

    Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。

- **（5）、发布/订阅**
最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。

Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。

## Redis 客户端连接池
java 客户端使用 JedisPool， JedisPool本质上是使用了 google的 commmons-pool 对象连接池来实现。

使用对象连接池可用减少对象的创建和销毁的开销。



# 参考
- [redis详解（三）-- 面试题](http://blog.csdn.net/guchuanyun111/article/details/52064870)
- [Redis的那些最常见面试问题](https://www.cnblogs.com/Survivalist/p/8119891.html)
- [2017年6月Java面试——redis](http://blog.csdn.net/sunqingzhong44/article/details/73866263)
- [坑人无数的Redis面试题](https://baijiahao.baidu.com/s?id=1588454565071211950&wfr=spider&for=pc)


