# 线程上下文切换

## 1. 背景知识

### 多核、多CPU、超线程、多线程

#### 多核
一个现代CPU除了处理器核心之外还包括寄存器、L1L2缓存这些存储设备、浮点运算单元、整数运算单元等一些辅助运算设备以及内部总线等。一个多核的CPU也就是一个CPU上有多个处理器核心，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，就意味着这个程序的不同线程需要经常在CPU之间的外部总线上通信，同时还要处理不同CPU之间不同缓存导致数据不一致的问题，所以在这种场景下多核单CPU的架构就能发挥很大的优势，通信都在内部总线，共用同一个缓存。
#### 多CPU
这个其实很容易想到，如果要运行多个程序（进程）的话，假如只有一个CPU的话，就意味着要经常进行进程上下文切换，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，所以 多个进程就必然要经常进行进程上下文切换，这个代价是很高的。

#### 超线程
简单来说是在一个CPU上真正的并发两个线程，听起来似乎不太可能，因为CPU都是分时的啊，其实这里也是分时，因为前面也提到一个CPU除了处理器核心还有其他设备，一段代码执行过程也不光是只有处理器核心工作，如果两个线程A和B，A正在使用处理器核心，B正在使用缓存或者其他设备，那AB两个线程就可以并发执行，但是如果AB都在访问同一个设备，那就只能等前一个线程执行完后一个线程才能执行。实现这种并发的原理是 在CPU里加了一个协调辅助核心，根据Intel提供的数据，这样一个设备会使得设备面积增大5%，但是性能提高15%~30%。

#### 多线程
一个进程里多线程之间可以共享变量，线程间通信开销也较小，可以更好的利用多核CPU的性能，多核CPU上跑多线程程序往往会比单线程更快，有的时候甚至在单核CPU上多线程程序也会有更好的性能，因为虽然多线程会有上下文切换和线程创建销毁开销，但是单线程程序会被IO阻塞无法充分利用CPU资源，加上线程的上下文开销较低以及线程池的大量应用，多线程在很多场景下都会有更高的效率。



### 1.1 CPU上下文切换
在每个任务运行前，CPU都需要知道任务从哪里加载，又是从哪里开始运行，也就是说，需要系统事先帮他设置好`CPU寄存器和程序计数器(Program Counter,PC)`

CPU寄存器包含指令寄存器(IR)和程序计数器(PC)，是CPU内置的容量小、但速度极快的内存。程序计数器，则是用来存储CPU正在执行的指令的位置，或者即将执行的下一条指令的位置。他们都是`CPU`在运行任何任务前，必须依赖的环境，因此也被叫做`CPU`上下文。


CPU上下文切换，就是先把前一个任务的CPU上下文(也就是CPU寄存器和程序计数器)保存起来，然后加载新任务的上下文，到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。
而保存下来的上下文，会存储在系统内核中，并在任务重新调度执行的时候再加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

根据任务的不同，CPU的上下文切换就可以分为几个不同的常见，也就是`进程上下文切换`,`线程上下文切换`以及`中断上下文切换`。

## 2 进程上下文切换

### 2.1 进程上下文切换

#### 2.1.1 系统调用
Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间。`CPU`特权等级的`Ring0`和`Ring3`。

![特权等级][1]
- 内核空间(`Ring 0`)具有最高权限，可以直接访问所有资源
- 用户空间(`Ring 3`)只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

换个角度看，也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行是，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。
从用户态到内核态的转变，需要通过系统调用来完成，比如当我们查看文件内容时，就需要多次系统调用来完成：首先调用open()打开文件，然后调用read()读取文件内容，并调用write()将内容写到标准输出，最后再调用close()关闭文件。

**系统调用的过程会发生CPU上下文切换**

CPU寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

而系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程，所以一次系统调用的过程，其实是发生了两次CPU上下文切换。

- 进程上下文切换，是指从一个进程切换到另一个进程运行。
- 而系统调用过程中一直是同一个进程在运行。

**系统调用过程通常称为特权模式切换**，而不是上下文切换。但实际上系统调用过程中，CPU的上下文切换还是无法避免的。

### 2.2 进程切换
首先需要知道的是，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包含了内核堆栈、寄存器等内核空间状态。

因此，进程的上下文切换就比系统调用多了一步：在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新新进程的虚拟内存和用户栈。如下图所示：

![上下文切换CPU时序][2]

另外，`Linux`通过`TLB(Translation Lookaside Buffer)`来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，`TLB`也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。

进程切换时才需要切换上下文，换句话说，只有在进程调度的时候，才需要切换上下文。Linux为每个CPU都维护了一个就绪队列，将获取进程(即正在运行和等待CPU的进程)按照优先级和等待CPU的时间排序，然后选择最需要CPU的进程，也就是优先级最高和等待CPU时间最长的进程来运行。

进程调度是一个比较复杂的算法，这里简要说明几种调度:
>
1. 为了保证所有进程可以得到公平调度，CPU时间片被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其他正在等待CPU的进程运行。
2. 进程在系统资源不足(比如内存不足)时，需要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
3. 当进程通过随眠函数sleep这样的方法将自己主动挂起时，自然也会重新调度。
4. 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级的进程来运行。
5. 当发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中中断服务程序。


### 2.3 进程上下文切换
线程与进程最大的区别在与，线程是调度的基本单位，而进程则是资源拥有的基本单位。说白了，所谓内核中的任务调用，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。

- 当进程只有一个线程时，可以认为进程就等于线程。
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。

另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

这么一来，线程的上下文切换其实就可以分为两种情况：
- 前后俩个线程属于不同进程，此时，由于资源不共享，所以切换过程就跟进程上下文切换是一样的。
- 前后两个线程属于同一个进程，此时，应为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据，寄存器等不共享的数据。
到这里你应该也发现了，虽然同为上下文切换，但同进程内的线程切换，要比多进程间切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。


### 2.4 中断上下文切换
除了前面两种上下文切换，还有一个场景也会也换CPU上下文，那就是中断。

为了快速响应硬件的时间，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备时间。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断打断了一个正处于用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序所必须的状态，包括CPU寄存器、内核堆栈、硬件中断等参数等。

对同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样的道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。

另外，跟进程上下文切换一样，中断上下文切换也需要消耗CPU，切换次数过多也会耗费大量的CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。


不管是哪种场景导致的上下文切换，你都应该知道：

CPU上下文切换，是保证Linux系统正常工作的核心功能之一，一般情况下不需要我们特别关注。
但过多的上下文切换，会把CPU时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。


## 3. 切换过程
在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB, process control block）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。

PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。

1. 保存进程A的状态（寄存器和操作系统数据）；
2. 更新PCB中的信息，对进程A的“运行态”做出相应更改；
3. 将进程A的PCB放入相关状态的队列；
4. 将进程B的PCB信息改为“运行态”，并执行进程B；
5. B执行完后，从队列中取出进程A的PCB，恢复进程A被切换时的上下文，继续执行A；

进程的上下文切换过程：
1. 切换页目录以使用新的地址空间；
2. 切换内核栈和硬件上下文；

对于Linux来说，线程和进程的最大区别就在于地址空间。对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。所以明显是进程切换代价大。**线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的**。这两种上下文切换的处理都是 通过操作系统内核来完成的。**内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。**

对于一个正在执行的进程包括 程序计数器、寄存器、变量的当前值等 ，而这些数据都是保存在CPU的寄存器中的，且这些寄存器只能是正在使用CPU的进程才能享用，在进程切换时，首先得保存上一个进程的这些数据（便于下次获得CPU的使用权时从上次的中断处开始继续顺序执行，而不是返回到进程开始，否则每次进程重新获得CPU时所处理的任务都是上一次的重复，可能永远也到不了进程的结束出，因为一个进程几乎不可能执行完所有任务后才释放CPU），然后将本次获得CPU的进程的这些数据装入CPU的寄存器从上次断点处继续执行剩下的任务。





[1]:https://upload-images.jianshu.io/upload_images/11547321-77fe829e06feb96e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/704/format/webp
[2]:https://upload-images.jianshu.io/upload_images/11547321-3962edebf309e068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/710/format/webp
